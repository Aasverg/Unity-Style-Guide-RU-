# Руководство по стилю Unity

В этой статье представлены идеи по созданию структуры проекта и соглашения об именовании скриптов и ресурсов в Unity.

## Оглавление

> 1.  [Введение](#introduction)
> 2.  [Структура проекта](#structure)
> 3.  [Сценарии](#scripts)
> 4.  [Соглашения об именовании активов](#anc)
> 5.  [Рабочие процессы управления активами](#asset-workflows)

## 1\. Введение

### Разделы

> 1.1 [Стиль](#style)

> 1.2 [Важная терминология](#importantterminology)

### 1.1 Стиль

#### Если в вашем проекте уже есть руководство по стилю, следует ему следовать.

Если вы работаете над проектом или в команде, у которых уже есть руководство по стилю, его следует соблюдать. Любые несоответствия между существующим руководством по стилю и данным руководством должны быть обоснованы существующим.

Однако руководства по стилю должны быть «живыми» документами, и вы должны предлагать изменения как в существующее руководство по стилю, так и в данное, если считаете, что это принесет пользу всем пользователям.

> ##### *Споры о стиле бессмысленны. Должен существовать справочник по стилю, и вы должны ему следовать.*
> 
> [*Ребекка Мерфи*](https://rmurphey.com)

#### Вся структура, ресурсы и код в любом проекте должны выглядеть так, будто их создал один человек, независимо от того, сколько людей внесли свой вклад.

Переход от одного проекта к другому не должен приводить к повторному изучению стиля и структуры. Соблюдение руководства по стилю устраняет ненужные догадки и двусмысленности.

Это также позволяет более продуктивно создавать и поддерживать документацию, поскольку не нужно думать о стиле, достаточно просто следовать инструкциям. Данное руководство по стилю написано с учетом лучших практик, а это значит, что, следуя ему, вы также сведете к минимуму трудноотслеживаемые проблемы.

#### Друзья не позволяют друзьям иметь плохой стиль.

Если вы видите, что кто-то работает вопреки руководству по стилю или вообще без руководства по стилю, постарайтесь его поправить.

При работе в команде или обсуждении в сообществе гораздо проще помогать и просить о помощи, когда люди последовательны. Никому не нравится помогать распутывать чей-то запутанный код или разбираться с ресурсами, названия которых им непонятны.

Если вы помогаете человеку, чья работа соответствует другому, но последовательному и разумному руководству по стилю, вы должны уметь адаптироваться к нему. Если же его работа не соответствует ни одному руководству по стилю, пожалуйста, направьте его сюда.

### 1.2 Важная терминология

#### Сборные дома

В Unity термин «префаб» используется для обозначения системы, позволяющей создавать, настраивать и хранить игровой объект (GameObject) со всеми его компонентами, значениями свойств и дочерними игровыми объектами в качестве многократно используемого ресурса (Asset).

#### Уровни/Карты/Сцена

Уровни — это то, что некоторые называют картами, а в Unity — сценами. Уровень представляет собой набор объектов.

#### Сериализуемый

Переменные, допускающие сериализацию, отображаются в окне инспектора в Unity. Для получения дополнительной информации см. документацию Unity по [параметру Serializable](https://docs.unity3d.com/Manual/script-Serialization.html) .

#### Случаи

Существует несколько способов присваивания имен предметам. Вот некоторые распространенные типы корпусов:

> ##### PascalCase
> 
> Все слова пишите с заглавной буквы и удаляйте все пробелы, например, `DesertEagle` , `StyleGuide` , `ASeriesOfWords` .
> 
> ##### camelCase
> 
> Первая буква всегда строчная, но каждое последующее слово начинается с заглавной буквы, например, `desertEagle` , `styleGuide` , `aSeriesOfWords` .
> 
> ##### строчные буквы
> 
> Все буквы строчные, например, `deserteagle` .
> 
> ##### Snake\_case
> 
> Слова могут начинаться произвольно с заглавной или строчной буквы, но разделяются подчеркиванием, например, `desert_Eagle` , `Style_Guide` , `a_Series_of_Words` .

**[⬆ Вернуться наверх](#table-of-contents)**

## 2\. Структура проекта

Структуру каталогов проекта следует считать незыблемой. Соглашения об именовании ресурсов и структура каталогов контента неразрывно связаны, и нарушение любого из них приводит к ненужному хаосу.

В этом стиле мы будем использовать структуру, которая в большей степени опирается на возможности фильтрации и поиска в окне проекта для тех, кто работает с ресурсами, чтобы находить ресурсы определенного типа, вместо другой распространенной структуры, которая группирует типы ресурсов с помощью папок.

> Использование префиксной [системы именования](#asset-name-modifiers) , то есть использование папок для хранения ресурсов схожих типов, таких как `Meshes` , `Textures` и `Materials` является избыточной практикой, поскольку типы ресурсов уже отсортированы по префиксу и могут быть отфильтрованы в браузере контента.

> ВАЖНО: Ресурсы для разработки (незавершенные работы или тестовые ресурсы, содержащиеся в `_Dev` ) всегда должны предваряться символом `_` для упрощения настройки в инспекторе.

Assets
    \_Dev(Use a \`\_\`to keep this folder at the top)
        DeveloperName
            (Work in progress assets)
    ProjectName
	    Characters
            	Anakin
            FX
	    	Particles
                Vehicles
                    Abilities
                        IonCannon
                            (Particle Systems, Textures)
                Weapons
            Gameplay
                Characters
                Equipment
                Input
		Triggers
		Quests
		Scene
                Vehicles
                    Abilities
                    Air
                        TieFighter
                            (Models, Textures, Materials, Prefabs)
            \_Levels
                Frontend
                Act1
                    Level1
            Lighting
                HDRI
                Lut
                Textures
            MaterialLibrary
            	Debug
            	Shaders
            Objects
                Architecture (Single use big objects)
                    DeathStar
                Props (Repeating objects to fill a level)
                    ObjectSets
                        DeathStar
            Scripts
                AI
                Gameplay
		    Triggers
		    Quests
                    Input
                Tools
            Sound
                Characters
                Vehicles
                    TieFighter
                        Abilities
                            Afterburners
                Weapons
            UI
                Art
                    Buttons
                Resources
                    Fonts
    ExpansionPack (DLC)
    Plugins
    ThirdPartySDK  

Причины такой структуры перечислены в следующих подразделах.

### Разделы

> 2.1 [Названия папок](#structure-folder-names)

> 2.2 [Папки верхнего уровня](#structure-top-level)

> 2.3 [Папки разработчика](#structure-developers)

> 2.4 [Уровня](#levels)

> 2.5 [Определение права собственности](#structure-ownership)

> 2.6 [`Assets` и `AssetTypes`](#structure-assettypes)

> 2.7 [Большие наборы](#structure-large-sets)

> 2.8 [Библиотека материалов](#structure-material-library)

> 2.9 [Структура сцены](#scene-structure)

### 2.1 Названия папок

Это общие правила именования любых папок в структуре содержимого.

#### Всегда используйте [PacalCase.](#terms-cases)

PascalCase означает, что имя начинается с заглавной буквы, и вместо пробелов каждое последующее слово также начинается с заглавной буквы. Например, `DesertEagle` , `RocketPistol` и `ASeriesOfWords` .

#### Никогда не используйте пробелы.

Повторяю [пункт 2.1.1](#2.1.1) : никогда не используйте пробелы. Пробелы могут привести к сбоям в работе различных инженерных инструментов и пакетных процессов. В идеале корневая директория вашего проекта также не должна содержать пробелов и должна располагаться, например, в папке `D:\Project` а не в `C:\Users\My Name\My Documents\Unity Projects` .

#### Никогда не используйте символы Юникода и другие знаки.

Если одного из ваших игровых персонажей зовут «Зои», то имя папки должно быть `Zoe` . Использование символов Юникода может быть хуже, чем [пробелы](#2.1.2) , в инженерных инструментах, а некоторые приложения для работы с компонентами также не поддерживают символы Юникода в путях.

В связи с этим, если в вашем проекте есть и на вашем компьютере есть символ Unicode (то есть ваше имя `— Зои`), любой проект, расположенный в `папке «Мои документы`», столкнётся с этой проблемой. Часто просто перенос проекта на что-то `вроде D:\Project` решает эти загадочные проблемы.

Использование других символов вне `a-z`, `A-Z` и `0-9`, таких как `@`, `-`, `_`, `,`, `*` и `#`, может привести к неожиданным и трудноотслеживаемым проблемам на других платформах, контролю версий и слабым инженерным инструментам.

#### Пустых папок нет.

Пустых папок быть не должно. Они загромождают браузер контента.

Если вы обнаружили, что в обозревателе контента есть пустая папка, которую вы не можете удалить, выполните следующие действия:

1.  Убедитесь, что вы используете систему контроля версий.
2.  Перейдите в папку на диске и удалите находящиеся в ней файлы.
3.  Закрыть редактор.
4.  Убедитесь, что состояние вашей системы контроля версий синхронизировано (например, если вы используете Perforce, выполните команду "Согласовать автономные рабочие файлы" для каталога с контентом).
5.  Откройте редактор. Убедитесь, что всё работает как положено. Если нет, вернитесь к исходным настройкам, выясните, что пошло не так, и попробуйте снова.
6.  Убедитесь, что папка удалена.
7.  Внесите изменения в систему контроля версий.

### 2.2 Используйте папку верхнего уровня для ресурсов, специфичных для проекта.

Все ресурсы проекта должны находиться в папке, названной в честь проекта. Например, если ваш проект называется «Generic Shooter», *все* его содержимое должно находиться в `Assets/GenericShooter` .

> Папка `Developers` не предназначена для ресурсов, от которых зависит ваш проект, и поэтому не является специфичной для проекта. Подробнее об этом см. в[разделе «Папки разработчиков»](#2.3) .

Такой подход обусловлен множеством причин.

#### Нет глобальных активов

В руководствах по стилю кода часто пишут, что не следует загрязнять глобальное пространство имен, и это следует тому же принципу. Когда разрешено существование ресурсов вне папки проекта, становится гораздо сложнее обеспечить строгую структуру, поскольку ресурсы, находящиеся вне папки, поощряют нежелательное поведение, заключающееся в отсутствии необходимости организовывать ресурсы.

Каждый ресурс должен иметь своё назначение, иначе ему не место в проекте. Если ресурс является экспериментальным тестовым образцом и не должен использоваться в проекте, его следует поместить в папку [`Developer`](#2.3) .

#### Сокращение миграционных конфликтов

При работе над несколькими проектами команда часто копирует ресурсы из одного проекта в другой, если они создали что-то полезное для обоих.

Разместив все ресурсы, относящиеся к конкретному проекту, в папке верхнего уровня, вы уменьшите вероятность конфликтов при миграции этих ресурсов в новый проект.

##### Пример основного материала

Например, предположим, вы создали основной материал в одном проекте, который хотите использовать в другом проекте, и поэтому перенесли этот ресурс. Если этот ресурс находится не в папке верхнего уровня, он может иметь имя, например, `Assets/MaterialLibrary/M_Master` . Если в целевом проекте еще нет основного материала, это должно сработать без проблем.

По мере продвижения работы над одним или обоими проектами их основные материалы могут изменяться, чтобы соответствовать конкретным задачам в рамках естественного процесса разработки.

Проблема возникает, например, когда художник для одного проекта создал хороший универсальный модульный набор статических моделей, а кто-то хочет включить этот набор статических моделей во второй проект. Если художник, создавший ресурсы, использовал экземпляры материалов на основе `Assets/MaterialLibrary/M_Master` , как ему было указано, то при миграции высока вероятность конфликта с ранее мигрированным ресурсом `Assets/MaterialLibrary/M_Master` .

Эту проблему сложно предсказать и учесть. Человек, занимающийся миграцией статических моделей, может не быть тем же человеком, который знаком с разработкой основного материала обоих проектов, и он может даже не знать, что рассматриваемые статические модели зависят от экземпляров материала, которые, в свою очередь, зависят от основного материала. Однако инструменту миграции требуется вся цепочка зависимостей для корректной работы, поэтому при копировании этих ресурсов в другой проект он будет вынужден взять `Assets/MaterialLibrary/M_Master` и перезаписать существующий ресурс.

Именно на этом этапе, если основные материалы для обоих проектов *каким-либо образом* несовместимы, вы рискуете нарушить работу всей библиотеки материалов проекта, а также любых других зависимостей, которые могли быть уже перенесены, просто потому, что ресурсы не были сохранены в папке верхнего уровня. Простая миграция статических мешей теперь становится очень сложной задачей.

#### Образцы, шаблоны и контент сторонних разработчиков предоставляются без риска.

Расширение к [пункту 2.2.2](#2.2.2) : если член команды решит добавить примеры контента, файлы шаблонов или ресурсы, приобретенные у стороннего поставщика, гарантируется, что эти новые ресурсы никоим образом не будут мешать проекту, за исключением случаев, когда корневая папка проекта имеет уникальное имя.

Нельзя полностью доверять контенту сторонних разработчиков в плане соответствия [правилу папок верхнего уровня](#2.2) . Существует множество ресурсов, большая часть содержимого которых находится в папке верхнего уровня, но при этом они могут содержать модифицированный примерный контент Unity, а также файлы уровней, загрязняющие глобальную папку `Assets` .

При соблюдении пункта [2.2](#2.2) , худший конфликт со сторонними ресурсами может возникнуть, если два сторонних ресурса содержат одинаковый примерный контент. Если все ваши ресурсы находятся в папке, специфичной для проекта, включая примерный контент, который вы могли переместить в свою папку, ваш проект никогда не сломается.

#### DLC, подпроекты и обновления легко поддерживать.

Если ваш проект планирует выпуск DLC или имеет несколько связанных с ним подпроектов, которые могут быть либо перенесены в отдельную папку, либо просто не включены в сборку, то ресурсы, относящиеся к этим проектам, должны иметь свою собственную отдельную папку верхнего уровня. Это значительно упростит интеграцию DLC с основным контентом проекта. Подпроекты также можно переносить и добавлять с минимальными усилиями. Если вам нужно изменить материал ресурса или добавить какое-либо специфическое поведение переопределения ресурса в патче, вы можете легко поместить эти изменения в папку патча и безопасно работать, не рискуя нарушить основной проект.

### 2.3 Используйте папку разработчика для локального тестирования

В процессе разработки проекта члены команды часто используют своего рода «песочницу», где могут свободно экспериментировать, не рискуя основным проектом. Поскольку эта работа может быть непрерывной, члены команды могут захотеть разместить свои ресурсы на сервере системы контроля версий проекта. Не всем командам требуется использование папок разработчика, но те, кто их использует, часто сталкиваются с распространенной проблемой, связанной с ресурсами, загруженными в систему контроля версий.

Члены команды очень легко могут случайно использовать ресурсы, которые еще не готовы к использованию, что вызовет проблемы после их удаления. Например, художник может работать над модульным набором статических моделей и все еще настраивать их размеры и привязку к сетке. Если создатель мира увидит эти ресурсы в основной папке проекта, он может использовать их по всему уровню, не зная, что они могут быть подвергнуты невероятным изменениям и/или удалению. Это приводит к огромным объемам работы, которую приходится выполнять всей команде для решения проблем.

Если бы эти модульные ресурсы были размещены в папке разработчика, у создателя мира не было бы причин их использовать, и вся эта проблема никогда бы не возникла.

Как только ресурсы будут готовы к использованию, художнику останется лишь переместить их в папку, относящуюся к конкретному проекту. По сути, это «перевод» ресурсов из экспериментального состояния в рабочее.

### 2.4 Все файлы [сцен](#terms-level-map) должны находиться в папке под названием Levels.

Файлы уровней невероятно специфичны, и для каждого проекта обычно используется своя собственная система именования карт, особенно если он работает с подуровнями или потоковыми уровнями. Независимо от того, какая система организации карт используется в конкретном проекте, все уровни должны находиться в `Assets/ProjectNameName/Levels` .

Возможность указать кому-либо, где находится конкретная карта, без необходимости объяснять её местоположение, значительно экономит время и в целом улучшает удобство использования. Обычно уровни находятся в подпапках папки `Levels` , например, `Levels/Campaign1/` или `Levels/Arenas` , но самое важное здесь то, что все они находятся в папке `Assets/ProjectNameName/Levels` .

Это также упрощает работу инженеров по созданию уровней. Управление уровнями для процесса сборки может быть крайне утомительным, если им приходится копаться в произвольных папках в поисках нужных уровней. Если все уровни команды находятся в одном месте, гораздо сложнее случайно не создать карту в процессе сборки. Это также упрощает скрипты сборки освещения, а также процессы контроля качества.

### 2.5 Определение права собственности

В командах, состоящих из нескольких человек, определите права собственности на зоны/ресурсы/функции. Некоторые ресурсы, такие как сцены или префабы, плохо переносят одновременные изменения несколькими людьми, что приводит к конфликтам. Наличие одного человека, который может изменять (или предоставлять право на изменение) тот или иной ресурс, помогает избежать этой проблемы.

### 2.6 Не создавайте папки с названиями `Assets` или `AssetTypes`

#### Создание папки с именем `Assets` излишне.

Все активы являются активами.

#### Создание папки с названием `Meshes` , `Textures` или `Materials` излишне.

Все названия ресурсов указаны с учетом их типа. Эти папки содержат только избыточную информацию, и их использование легко можно заменить надежной и простой в использовании системой фильтрации, предоставляемой Content Browser.

Хотите отображать только статические сетки в `Environment/Rocks/` ? Просто включите фильтр «Статические сетки». Если все ресурсы названы правильно, они также будут отсортированы в алфавитном порядке независимо от префиксов. Хотите отображать как статические, так и скелетные сетки? Просто включите оба фильтра. Это избавит от необходимости выбирать две папки в древовидном представлении обозревателя контента, `Control-Click` .

> Это также расширяет полный путь к ресурсу, не принося при этом существенной пользы. Префикс `SM_` для статической сетки состоит всего из трех символов, тогда как `Meshes/` — из семи.

Если этого не делать, это также предотвратит неизбежную ситуацию, когда кто-то поместит статическую сетку или текстуру в папку `Materials` .

### 2.7 Очень большие наборы ресурсов получают собственную структуру папок.

Это можно рассматривать как псевдоисключение из [пункта 2.6](#2.6) .

Существуют определенные типы ресурсов, которые содержат огромное количество связанных файлов, причем каждый ресурс имеет уникальное назначение. Два наиболее распространенных типа — это анимационные и звуковые ресурсы. Если у вас есть более 15 таких ресурсов, которые относятся к одной категории, их следует хранить вместе.

Например, анимации, используемые несколькими персонажами, должны располагаться в `Characters/Common/Animations` и могут иметь подпапки, такие как `Locomotion` или `Cinematic` .

> Это не относится к таким ресурсам, как текстуры и материалы. В папке `Rocks` обычно находится большое количество текстур, если в ней много камней, однако эти текстуры, как правило, относятся только к нескольким конкретным камням и должны быть названы соответствующим образом. Даже если эти текстуры являются частью [библиотеки материалов](#2.8) .

### 2.8 `MaterialLibrary`

Если в вашем проекте используются основные материалы, многослойные материалы или любые другие виды многократно используемых материалов или текстур, которые не относятся ни к одному подмножеству ресурсов, эти ресурсы должны располагаться в `Assets/ProjectName/MaterialLibrary` .

Таким образом, все «глобальные» материалы находят свое место хранения и легко обнаруживаются.

> Это также значительно упрощает внедрение политики «использовать только экземпляры материалов» в рамках проекта. Если все художники и ресурсы должны использовать экземпляры материалов, то единственные обычные ресурсы материалов, которые должны существовать, находятся в этой папке. Вы можете легко проверить это, выполнив поиск базовых материалов в любой папке, кроме `MaterialLibrary` .

`MaterialLibrary` не обязательно должна состоять только из материалов. Общие вспомогательные текстуры, функции материалов и другие подобные вещи также следует хранить здесь в папках, указывающих на их предназначение. Например, универсальные текстуры шума следует размещать в `MaterialLibrary/Utility` .

Все тестовые или отладочные материалы должны находиться в папке `MaterialLibrary/Debug` . Это позволяет легко удалять отладочные материалы из проекта перед выпуском и делает крайне очевидным, используются ли они в производственных ресурсах, если отображаются ошибки ссылок.

## 2.9 Структура сцены

Помимо иерархии проекта, существует также иерархия сцен. Как и прежде, мы представим вам шаблон. Вы можете настроить его под свои нужды. Используйте именованные пустые игровые объекты в качестве папок сцен.

@System
@Debug
@Management
@UI
    Layouts
Cameras
Lights
    Volumes
Particles
Sound
World
    Global
    Room1
        Architecture
        Terrain
        Props
Gameplay
	Actors
	Items
	Triggers
	Quests
\_Dynamic

*   Все пустые объекты должны располагаться в точке 0,0,0 с поворотом и масштабом по умолчанию.
*   Для пустых объектов, являющихся лишь контейнерами для скриптов, используйте префикс «@» — например, @Cheats
*   При создании экземпляра объекта во время выполнения обязательно поместите его в \_Dynamic — не загрязняйте корень вашей иерархии, иначе вам будет сложно в ней ориентироваться.

**[⬆ Вернуться наверх](#table-of-contents)**

## 3\. Сценарии

В этом разделе основное внимание будет уделено классам C# и их внутреннему устройству. По возможности, правила стиля соответствуют стандарту C# от Microsoft.

### Разделы

> 3.1 [Организация занятий](#classorganization)

> 3.2 [Компиляция](#compiling)

> 3.3 [Переменные](#variables)

> 3.4 [Функции](#functions)

### 3.1 Организация занятий

Исходные файлы должны содержать только один открытый тип, хотя допускается наличие нескольких внутренних классов.

В исходных файлах следует указывать имя открытого класса.

Организуйте пространства имен с четко определенной структурой.

Членов класса следует расположить в алфавитном порядке и сгруппировать по секциям:

*   Constant Fields
*   Static Fields
*   Fields
*   Constructors
*   Properties
*   Events / Delegates
*   LifeCycle Methods (Awake, OnEnable, OnDisable, OnDestroy)
*   Public Methods
*   Private Methods
*   Nested types

В каждой из этих групп отсортируйте по доступу:

*   public
*   internal
*   protected
*   private

```
namespace ProjectName
{
	/// <summary>  
	/// Brief summary of what the class does
	/// </summary>
    public class Account
    {
      #region Fields
      
      [Tooltip("Public variables set in the Inspector, should have a Tooltip")]
      public static string BankName;
      
	  /// <summary>  
	  /// They should also have a summary
	  /// </summary>
      public static decimal Reserves;
 
	  public string BankName;
	  public const string ShippingType = "DropShip";
	  
	  private float _timeToDie;
	  
	  #endregion
	  
	  #region Properties
	  
      public string Number {get; set;}
      public DateTime DateOpened {get; set;}
      public DateTime DateClosed {get; set;}
      public decimal Balance {get; set;}
            
	  #endregion
	 
	  #region LifeCycle
	  
      public Awake()
      {
        // ...
      }
      
      #endregion
	  #region Public Methods
	  
      public AddObjectToBank()
      {
        // ...
      }
      
      #endregion
    }
}
```

#### Шаблоны скриптов

Чтобы сэкономить время, вы можете заменить стандартный шаблон скрипта Unity своим собственным, чтобы автоматически настроить пространство имен, регионы и т. д. Подробнее об этом можно узнать в этой статье [поддержки](https://support.unity3d.com/hc/en-us/articles/210223733-How-to-customize-Unity-script-templates) Unity.

#### Пространство имен

Используйте пространство имен, чтобы гарантировать, что область видимости ваших классов/перечислений/интерфейсов и т. д. не будет конфликтовать с существующими областями видимости из других пространств имен или глобального пространства имен. Проект должен, как минимум, использовать имя проекта в качестве пространства имен, чтобы предотвратить конфликты с любыми импортированными сторонними ресурсами.

#### Для всех государственных мероприятий необходимо составить краткое описание.

Проще говоря, для любой функции, имеющей модификатор доступа Public, необходимо заполнить краткое описание.

```
/// <summary>
/// Fire a gun
/// </summary>
public void Fire()
{
// Fire the gun.
}
```

#### Группы раскладывающихся элементов

Если класс содержит лишь небольшое количество переменных, использование групп выпадающих списков не требуется.

Если класс содержит умеренное количество переменных (5-10), всем [сериализуемым](#serializable) переменным следует присвоить нестандартную группу вложений (Foldout Group). Часто это категория `Config` .

Для создания групп выпадающих списков в Unity есть 2 варианта.

*   Первый способ — определить `[Serializable] public Class` внутри основного класса, однако это может повлиять на производительность. Этот способ позволяет использовать одно и то же имя переменной.
*   Второй вариант — использовать атрибут Foldout Group, доступный в [Odin Inspector](https://odininspector.com/) .

```
[[Serializable](https://docs.unity3d.com/ScriptReference/Serializable.html)]
public struct PlayerStats
	{
        public int MovementSpeed;
    }
    
[FoldoutGroup("Interactable")]
public int MovementSpeed = 1;
```

#### Комментирование

Комментарии следует использовать для описания замысла, общего алгоритма и/или логической последовательности выполнения. В идеале, если бы, прочитав только комментарии, кто-либо, помимо автора, мог понять предполагаемое поведение функции и её общий принцип работы.

Хотя минимальных требований к количеству комментариев нет, и, безусловно, некоторые очень простые процедуры вообще не нуждаются в комментариях, предполагается, что большинство процедур будут иметь комментарии, отражающие замысел и подход программиста.

##### Стиль комментариев

Разместите комментарий на отдельной строке, а не в конце строки кода.

Начинайте текст комментария с заглавной буквы.

Завершайте текст комментария точкой.

Вставьте один пробел между разделителем комментариев (//) и текстом комментария, как показано в следующем примере.

В большинстве случаев следует использовать теги комментариев в стиле // (две косые черты). По возможности размещайте комментарии над кодом, а не рядом с ним. Вот несколько примеров:

```
        // Sample comment above a variable.
        private int _myInt = 5;
```

#### Регионы

Директива `#region` позволяет сворачивать и скрывать разделы кода в файлах C#. Возможность выборочного скрытия кода делает ваши файлы более управляемыми и удобными для чтения.

```
#region "This is the code to be collapsed"
    Private components As System.ComponentModel.Container
#endregion
```

#### Расстояние

После запятой между аргументами функции обязательно ставьте один пробел.

Пример: `Console.In.Read(myChar, 0, 1);`

*   После скобок и аргументов функции пробел не ставится.
*   Не используйте пробелы между именем функции и скобками.
*   Внутри скобок пробелы не используются.

### 3.2 Компиляция

Все скрипты должны компилироваться без предупреждений и ошибок. Предупреждения и ошибки в скриптах следует исправлять немедленно, так как они могут быстро привести к очень опасным и неожиданным последствиям.

*Не* отправляйте неработающие скрипты в систему контроля версий. Если вам необходимо сохранить их в системе контроля версий, лучше отложите их.

### 3.3 Переменные

Слова `variable` и `property` могут использоваться взаимозаменяемо.

#### Именование переменных

##### Существительные

Все имена переменных, не являющиеся логическими значениями, должны быть ясными, недвусмысленными и описательными существительными.

##### Случай

Все переменные используют PascalCase, за исключением тех, которые помечены как [приватные](#privatevariables) (в этом случае используется camelCase).

Для сокращений из 4 и более символов используйте PascalCase (3 символа должны быть написаны заглавными буквами).

##### Учтенный контекст

Имена переменных не должны дублировать контекст, поскольку все ссылки на переменные в классе всегда будут иметь контекст.

###### Примеры контекста, рассмотренные в данном исследовании:

Рассмотрим класс под названием `PlayerCharacter` .

**Плохой**

*   `PlayerScore`
*   `PlayerKills`
*   `MyTargetPlayer`
*   `MyCharacterName`
*   `CharacterSkills`
*   `ChosenCharacterSkin`

Все эти переменные названы избыточно. Подразумевается, что переменная представляет собой `PlayerCharacter` к которому она принадлежит, поскольку именно `PlayerCharacter` определяет эти переменные.

**Хороший**

*   `Score`
*   `Kills`
*   `TargetPlayer`
*   `Name`
*   `Skills`
*   `Skin`

#### Переменный уровень доступа

В C# переменные имеют концепцию уровня доступа. «Public» означает, что любой код вне класса может получить доступ к переменной. «Protected» означает, что только класс и любые дочерние классы могут получить доступ к этой переменной внутри себя. «Private» означает, что только этот класс и никакие дочерние классы не могут получить доступ к этой переменной. Переменные следует делать публичными только в случае необходимости.

Лучше использовать атрибут `[SerializeField]` вместо того, чтобы делать переменную общедоступной.

##### Локальные переменные

Для локальных переменных следует использовать стиль camelCase.

###### Локальные переменные с неявным типом

Используйте неявную типизацию для локальных переменных, когда тип переменной очевиден из правой части оператора присваивания или когда точный тип не имеет значения.

```
var var1 = "This is clearly a string.";
var var2 = 27;
var var3 = Convert.ToInt32(Console.ReadLine());
// Also used in for loops
for (var i = 0; i < bountyHunterFleets.Length; ++i) {};
```

Не используйте \`var\`, если тип не очевиден из правой части оператора присваивания. Пример

```
int var4 = ExampleClass.ResultSoFar();
```

##### Приватные переменные

Приватные переменные должны иметь префикс в виде подчеркивания `_myVariable` и использовать стиль camelCase.

Если не известно наверняка, что доступ к переменной должен осуществляться только внутри класса, в котором она определена, и никогда не в дочерних классах, не следует помечать переменные как private. Пока не появится возможность помечать переменные `protected` , используйте private только в тех случаях, когда вы точно знаете, что хотите ограничить использование в дочерних классах.

##### *Не* используйте венгерскую нотацию.

*Не* используйте венгерскую нотацию или любые другие обозначения типов в идентификаторах.

```
// Correct
int counter;
string name;
 
// Avoid
int iCounter;
string strName;
```

#### Переменные, доступные в редакторе.

##### Всплывающие подсказки

Все [сериализуемые](#serializable) переменные должны иметь описание в поле `[Tooltip]` , объясняющее, как изменение этого значения влияет на поведение скрипта.

##### Ползунок регулировки и диапазоны значений

Для всех [сериализуемых](#serializable) переменных следует использовать ползунок и диапазоны значений, если существует значение, которое переменной *не* следует присваивать.

Пример: В скрипте, генерирующем столбы для забора, может быть редактируемая переменная с именем `PostsCount` , и значение -1 не будет иметь смысла. Используйте поля диапазона `[Range(min, max)]` , чтобы установить 0 в качестве минимального значения.

Если в скрипте построения используется редактируемая переменная, для неё следует определить разумный диапазон значений ползунка, чтобы никто случайно не присвоил ей большое значение, которое может привести к сбою редактора.

Диапазон значений необходимо задавать только в том случае, если известны границы значения. В то время как диапазон значений, заданный ползунком, предотвращает случайный ввод больших чисел, неопределенный диапазон значений позволяет пользователю указать значение за пределами диапазона ползунка, которое может считаться «опасным», но при этом оставаться допустимым.

#### Типы переменных

##### Логические значения

###### Логический префикс

Все логические значения должны быть названы в формате PascalCase, но с префиксом в виде глагола.

Пример: используйте `isDead` и `hasItem` , **а не** `Dead` и `Item` .

###### Логические имена

При представлении общей информации все логические значения следует по возможности называть описательными прилагательными.

Старайтесь не использовать глаголы типа `isRunning` . Глаголы, как правило, приводят к сложным состояниям.

###### Булевы комплексные состояния

Не используйте логические значения для представления сложных и/или зависимых состояний. Это усложняет добавление и удаление состояний и делает их нечитаемыми. Вместо этого используйте перечисление.

Пример: При определении оружия **не** используйте `isReloading` и `isEquipping` , если оружие не может одновременно перезаряжаться и экипироваться. Определите перечисление с именем `WeaponState` и используйте вместо него переменную этого типа с именем `WeaponState` . Это значительно упростит добавление новых состояний к оружию.

##### Перечисления

Перечисления используют PascalCase и единственное число для имен перечислений и их значений. Исключение: перечисления битовых полей должны быть во множественном числе. Перечисления можно размещать вне пространства класса для обеспечения глобального доступа.

Пример:

```
public enum WeaponType
{
    Knife,
    Gun
}

// Enum can have multiple values
[Flags]
public enum Dockings
{
	None = 0,
	Top = 1,
}

public WeaponType Weapon
```

##### Массивы

К массивам применяются те же правила именования, что и выше, но их следует называть существительными во множественном числе.

Пример: используйте `Targets` , `Hats` и `EnemyPlayers` , а не `TargetList` , `HatArray` , `EnemyPlayerArray` .

##### Интерфейсы

Интерфейсы начинаются с заглавной буквы `I` а затем следует PascalCase.

Пример: `public interface ICanEat { }`

### 3.4 Функции, события и диспетчеры событий

В этом разделе описывается, как следует создавать функции, события и диспетчеры событий. Все, что относится к функциям, также относится и к событиям, если не указано иное.

#### Именование функций

Называние функций, событий и диспетчеров событий имеет критически важное значение. На основании одного только названия можно сделать определенные предположения о функциях. Например:

*   Является ли это чистой функцией?
*   Это получение информации о состоянии?
*   Это обработчик?
*   Какова его цель?

На все эти и многие другие вопросы можно ответить, если функции будут названы соответствующим образом.

#### Все функции должны быть глаголами.

Все функции и события выполняют какое-либо действие, будь то получение информации, вычисление данных или запуск взрыва. Поэтому все функции должны начинаться с глаголов. По возможности их следует формулировать в настоящем времени. Также необходимо указывать контекст того, что именно они делают.

Хорошие примеры:

*   `Fire` — хороший пример, если речь идёт о классе персонажа/оружия, поскольку это имеет контекст. Плохой — если речь идёт о бочке/траве/любом неоднозначном классе.
*   `Jump` — хороший пример, если речь идёт о классе «Персонаж», в противном случае требуется контекст.
*   `Explode`
*   `ReceiveMessage`
*   `SortPlayerArray`
*   `GetArmOffset`
*   `GetCoordinates`
*   `UpdateTransforms`
*   `EnableBigHeadMode`
*   `IsEnemy` - ["Is" — это глагол.](http://writingexplained.org/is-is-a-verb)

Плохие примеры:

*   `Dead` — это мертвый? Умертвый ли?
*   `Rock`
*   `ProcessData` — Неоднозначные слова, ничего не значащие.
*   `PlayerState` - Существительные неоднозначны.
*   `Color` — глагол без контекста или с неоднозначным существительным.

#### Функции, возвращающие логическое значение, должны задавать вопросы.

При написании функции, которая не изменяет состояние или модифицирует какой-либо объект и предназначена исключительно для получения информации, состояния или вычисления значения «да/нет», она должна задавать вопрос. Это также должно соответствовать [правилу глагола](#function-verbrule) .

Это чрезвычайно важно, поскольку, если вопрос не задан, может быть предположено, что функция выполняет действие и возвращает информацию о том, было ли это действие выполнено успешно.

Хорошие примеры:

*   `IsDead`
*   `IsOnFire`
*   `IsAlive`
*   `IsSpeaking`
*   `IsHavingAnExistentialCrisis`
*   `IsVisible`
*   `HasWeapon` - ["Has" — это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)
*   `WasCharging` - ["Was" - это прошедшая форма глагола "be".](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html) Используйте "was" применительно к "предыдущему кадру" или "предыдущему состоянию".
*   `CanReload` - ["Can" — это глагол.](http://grammar.yourdictionary.com/parts-of-speech/verbs/Helping-Verbs.html)

Плохие примеры:

*   `Fire` — горит? Будет ли огонь? Будет ли огонь?
*   `OnFire` — может быть спутан с диспетчером событий для запуска процессов.
*   `Dead` — это мертвый? Умернет ли он?
*   `Visibility` — Видно ли? Установить видимость? Описание условий полета?

#### Обработчики событий и диспетчеры должны начинать с `On`

Любая функция, обрабатывающая событие или отправляющая событие, должна начинаться с `On` и продолжать следовать [правилу глагола](#function-verbrule) .

Хорошие примеры:

*   `OnDeath` — распространённое словосочетание в играх.
*   `OnPickup`
*   `OnReceiveMessage`
*   `OnMessageRecieved`
*   `OnTargetChanged`
*   `OnClick`
*   `OnLeave`

Плохие примеры:

*   `OnData`
*   `OnTarget`

**[⬆ Вернуться наверх](#table-of-contents)**

## 4\. Правила именования активов

Правила именования следует воспринимать как закон. Проект, соответствующий правилам именования, может с невероятной легкостью управлять своими ресурсами, осуществлять поиск, анализ и поддержку.

Большинство вещей имеют префикс, который обычно представляет собой аббревиатуру типа актива, за которой следует нижнее подчеркивание.

**В ресурсах используется [PascalCase.](#cases)**

### 4.1 Название базового актива - `Prefix_BaseAssetName_Variant_Suffix`

Все активы должны иметь *базовое название актива* . Базовое название актива представляет собой логическую группу связанных активов. Любой актив, входящий в эту логическую группу, должен соответствовать стандарту `Prefix_BaseAssetName_Variant_Suffix` .

Как правило, для создания хороших названий активов достаточно помнить о шаблоне `Prefix_BaseAssetName_Variant_Suffix` и руководствоваться здравым смыслом. Вот несколько подробных правил, касающихся каждого элемента.

`Prefix` и `Suffix` определяются типом актива с помощью следующих таблиц [модификаторов названия актива](#asset-name-modifiers) .

`BaseAssetName` должен определяться коротким и легко узнаваемым именем, связанным с контекстом данной группы ресурсов. Например, если у вас есть персонаж по имени Боб, все ресурсы Боба будут иметь `BaseAssetName` равный `Bob` .

Для уникальных и специфических вариантов ресурсов, `Variant` — это либо короткое и легко узнаваемое имя, представляющее собой логическую группу ресурсов, являющихся подмножеством базового имени ресурса. Например, если у Боба несколько скинов, эти скины должны по-прежнему использовать `Bob` в качестве `BaseAssetName` , но включать узнаваемый `Variant` . Скин «Evil» будет называться `Bob_Evil` , а скин «Retro» — `Bob_Retro` .

Для уникальных, но общих вариантов объектов, `Variant` — это двухзначное число, начинающееся с `01` Например, если у вас есть художник по окружению, создающий ничем не примечательные камни, они будут называться `Rock_01` , `Rock_02` , `Rock_03` и т. д. За редкими исключениями, вам никогда не следует требовать трехзначный номер варианта. Если у вас более 100 объектов, вам следует рассмотреть возможность организации их с использованием разных базовых имен или нескольких имен вариантов.

В зависимости от способа создания вариантов ваших ресурсов, вы можете объединять имена вариантов в цепочки. Например, если вы создаете ресурсы для напольных покрытий для проекта архитектурной визуализации, следует использовать базовое имя `Flooring` с цепочками вариантов, такими как `Flooring_Marble_01` , `Flooring_Maple_01` , `Flooring_Tile_Squares_01` .

#### Примеры

##### Характер

| Asset Type | Asset Name |
| --- | --- |
| Skeletal Mesh | SK\_Bob |
| Material | М\_Боб |
| Texture (Diffuse/Albedo) | Т\_Боб\_Д |
| Texture (Normal) | Т\_Боб\_Н |
| Texture (Evil Diffuse) | T\_Bob\_Evil\_D |

##### Пропеллер

| Asset Type | Asset Name |
| --- | --- |
| Static Mesh (01) | SM\_Rock\_01 |
| Static Mesh (02) | SM\_Rock\_02 |
| Static Mesh (03) | SM\_Rock\_03 |
| Material | М\_Рок |
| Material Instance (Snow) | MI\_Rock\_Snow |

### 4.2 Модификаторы названия актива

При присвоении имени активу используйте эти таблицы для определения префикса и суффикса, которые следует использовать с [базовым именем](#base-asset-name) актива.

#### Разделы

> 4.2.1 [Наиболее распространенный](#anc-common)

> 4.2.2 [Анимации](#anc-animations)

> 4.2.3 [Искусственный интеллект](#anc-ai)

> 4.2.4 [Готовые конструкции](#anc-prefab)

> 4.2.5 [Материалы](#anc-materials)

> 4.2.6 [Текстуры](#anc-textures)

> 4.2.7 [Разное](#anc-misc)

> 4.2.8 [Физика](#anc-physics)

> 4.2.9 [Аудио](#anc-audio)

> 4.2.10 [Пользовательский интерфейс](#anc-ui)

> 4.2.11 [Эффекты](#anc-effects)

#### Наиболее распространенный

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Уровень / Сцена | \* |  | Должно находиться в папке с названием Levels. Например, Levels/A4\_C17\_Parking\_Garage.unity |
| Level (Persistent) |  | \_P |  |
| Уровень (аудио) |  | \_Аудио |  |
| Level (Lighting) |  | Освещение |  |
| Level (Geometry) |  | \_Гео |  |
| Level (Gameplay) |  | \_Игровой процесс |  |
| Prefab |  |  |  |
| Probe (Reflection) | RP\_ |  |  |
| Probe (Light) | LP\_ |  |  |
| Volume | V\_ |  |  |
| Trigger Area |  | \_Курок |  |
| Material | M\_ |  |  |
| Static Mesh | SM\_ |  |  |
| Skeletal Mesh | SK\_ |  |  |
| Texture | T\_ | \_? | См. текстуры |
| Visual Effects | VFX\_ |  |  |
| Particle System | PS\_ |  |  |
| Light | L\_ |  |  |
| Camera (Cinemachine) | CM\_ |  | Виртуальная камера |

#### 4.2.1a 3D-модели (файлы FBX)

PascalCase

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Characters | CH\_ |  |  |
| Vehicles | VH\_ |  |  |
| Weapons | WP\_ |  |  |
| Static Mesh | SM\_ |  |  |
| Skeletal Mesh | SK\_ |  |  |
| Skeleton | SKEL\_ |  |  |
| Rig | RIG\_ |  |  |

#### 4.2.1b 3D-модели (3ds Max)

Все модели в 3ds Max написаны строчными буквами, чтобы отличать их от экспортированных в FBX файлов.

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Mesh |  | \_mesh\_lod0\* | Суффикс LOD следует использовать только в том случае, если модель использует уровни детализации (LOD). |
| Mesh Collider |  | \_коллайдер |  |

#### 4.2.2 Анимации

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Animation Clip | A\_ |  |  |
| Animation Controller | AC\_ |  |  |
| Avatar Mask | AM\_ |  |  |
| Morph Target | MT\_ |  |  |

#### 4.2.3 Искусственный интеллект

| Asset Type | Prefix | Suffix | Примечания |
| --- | --- | --- | --- |
| AI / NPC | AI\_ | \_NPC | \*NPC может быть пешкой CH\_ !AI\_ |
| Behavior Tree | BT\_ |  |  |
| Blackboard | BB\_ |  |  |
| Decorator | BTDecorator\_ |  |  |
| Service | BTService\_ |  |  |
| Task | BTTask\_ |  |  |
| Environment Query | EQS\_ |  |  |
| EnvQueryContext | EQS\_ | Контекст |  |

#### 4.2.4 Префабы

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Prefab |  |  |  |
| Prefab Instance | I |  |  |
| Scriptable Object |  |  | В редакторе присвоена метка "Чертеж". |

#### 4.2.5 Материалы

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Material | M\_ |  |  |
| Material Instance | MI\_ |  |  |
| Physical Material | PM\_ |  |  |
| Material Shader Graph | MSG\_ |  |  |

#### 4.2.6 Текстуры

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Texture | T\_ |  |  |
| Texture (Base Color) | T\_ | \_BC | Diffuse / Albedo |
| Texture (Metallic / Smoothness) | T\_ | \_MS |  |
| Texture (Normal) | T\_ | \_N |  |
| Texture (Alpha) | T\_ | \_A |  |
| Texture (Height) | T\_ | \_H |  |
| Texture (Ambient Occlusion) | T\_ | \_AO |  |
| Texture (Emissive) | T\_ | \_E |  |
| Texture (Mask) | T\_ | \_M |  |
| Texture (Packed) | T\_ | \_\* | См. примечания ниже о упаковке . |
| Texture Cube | TC\_ |  |  |
| Media Texture | MT\_ |  |  |
| Render Target | RT\_ |  |  |
| Cube Render Target | RTC\_ |  |  |
| Texture Light Profile | TLP\_ |  |  |

#### 4.2.6.1 Упаковка текстур

Обычно несколько слоев текстурных данных упаковывают в одну текстуру. Например, каналы Emissive, Roughness и Ambient Occlusion объединяют в качестве каналов Red, Green и Blue текстуры соответственно. Чтобы определить суффикс, просто сложите вместе указанные выше буквы суффикса, например, `_ERO` .

> Как правило, допустимо включать слой альфа-канала/прозрачности в альфа-канал диффузного/альбедо-фильтра, и, поскольку это распространенная практика, добавление `A` к суффиксу `_D` является необязательным.

Упаковка 4 каналов данных в текстуру (RGBA) не рекомендуется, за исключением маски альфа-канала/прозрачности в альфа-канале диффузного/альбедо канала, поскольку текстура с альфа-каналом создает больше накладных расходов, чем текстура без него.

#### 4.2.7 Разное

| Asset Type | Префикс | Суффикс | Примечания |
| --- | --- | --- | --- |
| Universal Render Pipeline Asset | URP\_ |  |  |
| HD Render Pipeline Asset | HDRP\_ |  |  |
| Post Process Volume Profile | PP\_ |  |  |
| User Interface | UI\_ |  |  |

#### 4.2.8 Физика

| Asset Type | Prefix | Suffix | Примечания |
| --- | --- | --- | --- |
| Physical Material | PM\_ |  |  |

#### 4.2.9 Аудио

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Audio Clip | A\_ |  |  |
| Audio Mixer | MIX\_ |  |  |
| Dialogue Voice | DV\_ |  |  |
| Audio Class |  |  | Без префикса/суффикса. Следует поместить в папку под названием AudioClasses. |

#### 4.2.10 Пользовательский интерфейс

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Font | Font\_ |  |  |
| Texture (Sprite) | T\_ | \_GUI |  |

#### 4.2.11 Эффекты

| Asset Type | Prefix | Suffix | Notes |
| --- | --- | --- | --- |
| Particle System | PS\_ |  |  |
| ⬆ Вернуться наверх |  |  |  |

## 5\. Рабочие процессы управления активами

В этом разделе описаны лучшие практики создания и импорта ресурсов, пригодных для использования в Unity.

### Разделы

> 5.1 [Настройки импорта ресурсов Unity](#unityimport)
> 
> 5.2 [3ds Max](#3dsmax)
> 
> 5.3 [Текстуры](#textures)
> 
> 5.4 [Аудио](#audio)

### 5.1 Настройки импорта ресурсов Unity

[Компонент AssetPostprocessor](https://docs.unity3d.com/ScriptReference/AssetPostprocessor.html) в Unity позволяет подключаться к конвейеру импорта и запускать скрипты до или после импорта ресурсов. Это позволяет принудительно устанавливать параметры импорта при первом импорте ресурсов в проект. Например, текстуры, заканчивающиеся на `_N` могут быть помечены как карты нормалей при импорте.

Пример инструкции по импорту настроек:

[https://github.com/justinwasilenko/Unity-AssetPostProcessor](https://github.com/justinwasilenko/Unity-AssetPostProcessor)

### 5.2 3ds Max

Инструкция по импорту из 3ds Max в Unity:

[https://docs.unity3d.com/2017.4/Documentation/Manual/HOWTO-ImportObjectMax.html](https://docs.unity3d.com/2017.4/Documentation/Manual/HOWTO-ImportObjectMax.html)

Учебное пособие по Unity по пакету FBX Exporter для обработки FBX-данных:

[https://learn.unity.com/project/3ds-max-to-unity-pipeline](https://learn.unity.com/project/3ds-max-to-unity-pipeline)

#### Настройка 3ds Max

В Unity используется 1 единица = 1 метр. Чтобы настроить 3ds Max на использование метров, перейдите в раздел `Customize/Units Setup/System Unit Setup` и установите значение 1 единица = 1 метр. Использование правильного масштаба очень важно для корректной работы физики, глобального освещения и взаимодействия в VR.

В 3ds Max частоту кадров анимации следует установить на 30 кадров в секунду. В диалоговом окне « `Time Configuration` находятся настройки частоты кадров 3ds Max.

##### Работа с мелкими предметами

*   Установите значение `Customize > Customize User Interface > Mouse Wheel Zoom Increment` равным 0,1 м, чтобы предотвратить чрезмерное масштабирование.
    
*   Включите функцию отсечения области просмотра и установите ползунок сбоку области просмотра, чтобы иметь возможность увеличивать масштаб небольших сеток. ( [https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/sfdcarticles/sfdcarticles/Viewport-Clipping.html](https://knowledge.autodesk.com/support/3ds-max/learn-explore/caas/sfdcarticles/sfdcarticles/Viewport-Clipping.html) )
    

#### Моделирование в 3ds Max

*   Следуйте [правилам именования активов.](#anc-models)
*   Избегайте слишком длинных тонких треугольников (это ускоряет рендеринг на основе тайлов и способствует правильному запеканию глобального освещения).
*   Используйте взвешенные по площади и углу нормали сетки (настройка импорта в Unity или создание в 3ds Max).

#### Экспорт из 3ds Max в Unity

##### Настройки экспорта:

*   Triangulate On
*   Tangents and Binormals Off
*   Smoothing Groups On
*   Preserve edge orientation On
*   Units - Automatic Off / Scene Units converted to Meters
*   Axis Conversion Z-up

Модели, созданные в 3ds Max, используют другую систему координат, чем Unity. Для корректного импорта в Unity необходимо повернуть точку опоры модели на +90 градусов по оси X.

Чтобы сделать это быстро, откройте редактор MaxScript, вставьте этот код, выделите его и перетащите на панель инструментов в 3ds Max, чтобы создать кнопку, которая будет запускать этот скрипт. Она применяет модификатор Xform для поворота точки опоры перед экспортом.

```
fn RotateCreationPivot obj rot =
(
select obj
modPanel.addModToSelection (XForm ()) ui:on
obj.modifiers[#XForm].gizmo.rotation += rot as quat
rotate obj (inverse rot as quat)
)
RotateCreationPivot $ (eulerToQuat(eulerAngles 90 0 0))
```

Скрипт для поворота всех объектов в сцене 3ds Max для экспорта.

```
(
    mapped fn ProcessObjectsForUnity node =
    (
        resetxform node
        tm = rotatexmatrix 90
        tm.row4 = node.pos
        node.transform = tm
        node.objectoffsetrot = eulerangles -90 0 0
    )
    
    ProcessObjectsForUnity geometry
)
```

*   Пакетный экспортер для 3ds Max ( [http://www.strichnet.com/improving-the-fbx-workflow-between-3ds-max-and-unity3d/](http://www.strichnet.com/improving-the-fbx-workflow-between-3ds-max-and-unity3d/) )

##### Экспорт CAT-анимации в формат FBX

Привяжите обычные кости к ригу CAT для использования при создании скелета и экспорте.

###### Поза связывания

В панели «Установка анимации»/«Менеджер слоев»/«Настройки/Режим анимации» переключите переключатель в `Red` Выберите только кости и сетку, которые вы хотите экспортировать. Именование экспорта: ModelName.FBX

###### Анимация

Установите для панели «Анимация»/«Менеджер слоев»/«Настройка/Режим анимации» значение `Green` Выберите ТОЛЬКО необходимые кости в вашей иерархии (они должны точно соответствовать костям, используемым для позы привязки), не включайте сетку. Именование экспорта: [ModelName@AnimationName.FBX](mailto:ModelName@AnimationName.FBX) Символ @ — это специальная система именования в Unity, позволяющая привязать анимацию к файлу Human.fbx в редакторе Unity.

#### Импорт из 3ds Max в Unity

Если импортируются только анимация или кости из файла FBX:

*   Установите параметр импорта `Preserve Hierarchy Model` в `True`
*   Установите для `Rig > Avatar Definition` `Copy From Other Avatar`

Окно MaxListener позволяет задать ширину и высоту выбранных костей, а возможно, и объектов? $.width = 0.01 $ .height = 0.01

**[⬆ Вернуться наверх](#table-of-contents)**

### 5.3 Текстуры

*   Текстуры соответствуют приведенной выше [системе именования](#anc-textures) .
*   Они являются степенью двойки (например, 512 x 512 или 256 x 1024).
*   По возможности используйте атласы текстур.
*   Для обеспечения согласованности при сохранении или экспорте 3D-программы должны указывать на текстуры проекта Unity.
*   Если разрешение текстуры в игре уже известно, лучше изменить его размер в Photoshop, чем использовать параметры сжатия Unity. Это уменьшит размер файла и время импорта текстуры в Unity.
*   При работе с исходным PSD-файлом высокого разрешения вне вашего проекта Unity используйте одно и то же имя как для файла высокого разрешения, так и для импортированного файла Unity. Это позволит быстро переключаться между двумя текстурами.

Более подробную информацию об импорте текстур можно найти здесь: [https://docs.unity3d.com/Manual/ImportingTextures.html](https://docs.unity3d.com/Manual/ImportingTextures.html)

Для текстур, требующих использования альфа-канала, следует руководствоваться следующими инструкциями: [https://docs.unity3d.com/Manual/HOWTO-alphamaps.html](https://docs.unity3d.com/Manual/HOWTO-alphamaps.html)

##### Формат файла текстуры

Все текстуры должны быть в формате .PSD. Слои не должны быть включены, и в импортированном файле должен быть только один альфа-канал.

**[⬆ Вернуться наверх](#table-of-contents)**

### 5.4 Аудио

Импортируйте в Unity только несжатые аудиофайлы в форматах WAV или AIFF.

Отличное руководство по [оптимизации импорта аудио в Unity.](https://www.gamedeveloper.com/audio/unity-audio-import-optimisation---getting-more-bam-for-your-ram)

**[⬆ Вернуться наверх](#table-of-contents)**

#### Список использованных источников в статье:

[https://unity3d.com/learn/tutorials/topics/tips/large-project-organisation](https://unity3d.com/learn/tutorials/topics/tips/large-project-organisation) [https://github.com/Allar/ue4-style-guide](https://github.com/Allar/ue4-style-guide) [http://www.arreverie.com/blogs/unity3d-best-practices-folder-structure-source-control/](http://www.arreverie.com/blogs/unity3d-best-practices-folder-structure-source-control/)
